---
layout: post
title: '[ë°±ì¤€ / Python] 1504 íŠ¹ì •í•œ ìµœë‹¨ ê²½ë¡œ'
subtitle:
date: 2021-04-21 17:00:00
author: 'Kyun2da'
header-style: text
tags:
  - ì•Œê³ ë¦¬ì¦˜
  - ë‹¤ìµìŠ¤íŠ¸ë¼
# 0ï¸âƒ£ 1ï¸âƒ£ 2ï¸âƒ£ 3ï¸âƒ£ 4ï¸âƒ£ 5ï¸âƒ£ 6ï¸âƒ£ 7ï¸âƒ£ 8ï¸âƒ£ 9ï¸âƒ£ ğŸ”Ÿ
---

## 1ï¸âƒ£ ì„œë¡ 

ì´ ë¬¸ì œëŠ” ë°±ì¤€ [1504 íŠ¹ì •í•œ ìµœë‹¨ ê²½ë¡œ](https://www.acmicpc.net/problem/1504) ë¬¸ì œì— ëŒ€í•œ í’€ì´ì´ë©° `íŒŒì´ì¬(Python)`ìœ¼ë¡œ í•´ê²°í•˜ì˜€ë‹¤.

## 2ï¸âƒ£ ë¬¸ì œ ì„¤ëª…

ì„¸ì¤€ì´ëŠ” 1ë²ˆ ì •ì ì—ì„œ Në²ˆ ì •ì ìœ¼ë¡œ ìµœë‹¨ ê±°ë¦¬ë¡œ ì´ë™í•˜ë ¤ê³  í•œë‹¤. ë˜í•œ ì„ì˜ë¡œ ì£¼ì–´ì§„ ë‘ ì •ì ì€ ë°˜ë“œì‹œ í†µê³¼í•´ì•¼ í•œë‹¤. ì£¼ì–´ì§„ ë‘ ì •ì ì„ ë°˜ë“œì‹œ ê±°ì¹˜ë©´ì„œ ìµœë‹¨ ê²½ë¡œë¡œ ì´ë™í•˜ëŠ” ìµœë‹¨ ê²½ë¡œì˜ ê¸¸ì´ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤.

## 3ï¸âƒ£ í’€ì´

ë…¸ë“œì™€ ë…¸ë“œ ì‚¬ì´ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•  ë•ŒëŠ” `ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜`ì„ ì‚¬ìš©í•œë‹¤. ì´ ë¬¸ì œì—ì„œ ì‹œì‘ì , ì£¼ì–´ì§„ ì •ì 1, ì£¼ì–´ì§„ ì •ì 2, ë„ì°©ì ì´ ìˆëŠ”ë° ë„¤ ê°œì˜ ì ì„ ê°–ê³  ì ì˜ ìˆœì„œëŠ” ì‹œì‘ì ê³¼ ë„ì°©ì ì˜ ìœ„ì¹˜ê°€ ê³ ì •ì´ê¸° ë•Œë¬¸ì— ë‘ ê°€ì§€ ë°–ì— ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤.

1. ì‹œì‘ì  -> ì •ì 1 -> ì •ì 2 -> ë„ì°©ì 
2. ì‹œì‘ì  -> ì •ì 2 -> ì •ì 1 -> ë„ì°©ì 

ìœ„ì˜ ê²½ë¡œë¥¼ ë‹¤ìµìŠ¤íŠ¸ë¼ë¡œ ê°ê° êµ¬í•´ì„œ ë” ì‘ì€ ê²½ë¡œì˜ ê¸¸ì´ê°€ ì´ ë¬¸ì œì˜ ë‹µì´ ëœë‹¤. ìœ„ì˜ ê²½ë¡œë¥¼ ë‹¤ìµìŠ¤íŠ¸ë¼ í˜•íƒœë¡œ í‘œí˜„í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

1. ì‹œì‘ì  -> ì •ì 1ì˜ ìµœë‹¨ê²½ë¡œ + ì •ì 1 -> ì •ì 2ì˜ ìµœë‹¨ê²½ë¡œ + ì •ì 2 -> ë„ì°©ì ì˜ ìµœë‹¨ê²½ë¡œì˜ ê¸¸ì´
2. ì‹œì‘ì  -> ì •ì 2ì˜ ìµœë‹¨ê²½ë¡œ + ì •ì 1 -> ì •ì 1ì˜ ìµœë‹¨ê²½ë¡œ + ì •ì 1 -> ë„ì°©ì ì˜ ìµœë‹¨ê²½ë¡œì˜ ê¸¸ì´

ì´ë¥¼ ì½”ë“œë¡œ í‘œí˜„í•˜ë©´ ì•„ë˜ì™€ ê°™ë‹¤.

## 4ï¸âƒ£ ì½”ë“œ

```python
import sys
import heapq

input = sys.stdin.readline
INF = sys.maxsize

n, e = map(int, input().split())

graph = [[] for _ in range(n + 1)]
for _ in range(e):
    a, b, c = map(int, input().split())
    graph[a].append([b, c])
    graph[b].append([a, c])

v1, v2 = map(int, input().split())


def dijkstra(start):
    q = []
    distance = [INF] * (n + 1)
    distance[start] = 0

    heapq.heappush(q, (0, start))
    distance[start] = 0
    while q:
        dist, now = heapq.heappop(q)
        if distance[now] < dist:
            continue
        for i in graph[now]:
            cost = dist + i[1]
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q, (cost, i[0]))

    return distance


one = dijkstra(1)
v1_distance = dijkstra(v1)
v2_distance = dijkstra(v2)

answer = min(one[v1] + v1_distance[v2] + v2_distance[n], one[v2] + v2_distance[v1] + v1_distance[n])

if answer < INF:
    print(answer)
else:
    print(-1)
```

## 5ï¸âƒ£ ë§ˆì¹˜ë©°

ë‹¤ìµìŠ¤íŠ¸ë¼ê°€ ì‚´ì§ ì‘ìš©ëœ ë¬¸ì œì—¬ì„œ ì²˜ìŒì— ì–´ë–»ê²Œ í’€ì–´ì•¼ í• ì§€ ê³ ë¯¼ì„ ë§ì´ í–ˆëŠ”ë° ë…¸ë“œì™€ ë…¸ë“œì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ê²ƒì— íŒíŠ¸ë¥¼ ì–»ì–´ ì•„ì´ë””ì–´ë¥¼ ì‰½ê²Œ ìƒê°í•  ìˆ˜ ìˆì—ˆë‹¤. ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ë§Œ ì•Œê³  ìˆì—ˆë‹¤ë©´ ê·¸ë ‡ê²Œ ì–´ë ¤ìš´ ë¬¸ì œëŠ” ì•„ë‹ˆì—ˆë˜ ê²ƒ ê°™ë‹¤.
